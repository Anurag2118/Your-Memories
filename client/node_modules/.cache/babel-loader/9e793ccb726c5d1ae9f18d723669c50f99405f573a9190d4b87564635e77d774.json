{"ast":null,"code":"import{useEffect,useState}from\"react\";import axios from\"axios\";import{useGetUserID}from\"../hooks/useGetUserID\";import{useCookies}from\"react-cookie\";import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";export const Home=()=>{const[memories,setMemories]=useState([]);// Initialize savedMemories as an empty array\nconst[savedMemories,setSavedMemories]=useState([]);const[cookies,_]=useCookies([\"access_token\"]);const userID=useGetUserID();// Hook to get the user ID\n// Effect to fetch initial memories and saved memories\nuseEffect(()=>{// Function to fetch all memories\nconst fetchMemories=async()=>{try{const response=await axios.get(\"http://localhost:3001/memories\");setMemories(response.data);console.log(\"Memories fetched successfully.\");}catch(err){console.error(\"Error fetching memories:\",err);}};// Function to fetch the IDs of memories saved by the current user\nconst fetchSavedMemories=async()=>{if(!userID){console.log(\"userID not available yet, skipping fetchSavedMemories\");// Ensure savedMemories is empty if no user is logged in\nsetSavedMemories([]);return;}try{console.log(\"Attempting to fetch saved memories for userID:\",userID);// This GET endpoint should return an object like { savedMemories: [\"id1\", \"id2\"] }\nconst response=await axios.get(\"http://localhost:3001/memories/savedMemories/ids/\".concat(userID));console.log(\"Fetched saved memories response:\",response.data);// Expecting response.data.savedMemories to be an array. Default to empty array if not.\n// This handles the initial load of saved memory IDs\nsetSavedMemories(response.data.savedMemories||[]);console.log(\"Saved memories state initialized from fetch.\");}catch(err){console.error(\"Error fetching saved memories:\",err);// In case of error, ensure savedMemories is at least an empty array\nsetSavedMemories([]);}};// Fetch all memories on component mount\nfetchMemories();// Fetch saved memories only if the user is logged in (token and userID available)\n// This will run on mount and whenever the access_token or userID changes\nif(cookies.access_token&&userID){fetchSavedMemories();}else{// If not logged in, ensure savedMemories is an empty array\nsetSavedMemories([]);}},[cookies.access_token,userID]);// Dependencies: re-run if token or userID changes\n// Function to handle saving a memory\nconst saveMemory=async memoryID=>{console.log(\"Save button clicked for memoryID:\",memoryID);console.log(\"Current userID:\",userID);console.log(\"Current access_token:\",cookies.access_token);// Prevent saving if user is not logged in or token is missing\nif(!userID||!cookies.access_token){console.log(\"Cannot save: User not logged in or token missing.\");// You might want to show a UI message to the user here, e.g., \"Please log in to save memories.\"\nreturn;}try{console.log(\"Attempting to send PUT request to save memory...\");// This PUT endpoint should expect { memoryID: \"...\", userID: \"...\" }\n// and should *return* the *updated* list of saved memory IDs for the user.\nconst response=await axios.put(\"http://localhost:3001/memories\",// Make sure this is the correct endpoint for saving\n{memoryID,userID},{headers:{authorization:cookies.access_token}// Sending the auth token\n});console.log(\"Response from PUT /memories:\",response.data);// **IMPORTANT:** We expect response.data to contain the *updated* list of saved memory IDs\n// e.g., { message: \"Saved!\", savedMemories: [\"id1\", \"id2\", \"newlySavedId\"] }\nif(response.data&&Array.isArray(response.data.savedMemories)){// Update the savedMemories state with the latest list from the backend\nsetSavedMemories(response.data.savedMemories);console.log(\"Saved memories state updated successfully from API response.\");}else{// Log an error if the backend response format is unexpected\nconsole.error(\"API response did not contain expected 'savedMemories' array:\",response.data);// Optionally, re-fetch the saved memories after a short delay\n// setTimeout(fetchSavedMemories, 1000); // Consider adding a delay and error handling\n}}catch(err){console.error(\"Error saving memory:\",err);// Log detailed error info if available\nif(err.response){console.error(\"Server responded with error status:\",err.response.status);console.error(\"Server error data:\",err.response.data);}else if(err.request){console.error(\"No response received from server.\");}else{console.error(\"Error setting up request:\",err.message);}// You might want to show an error message to the user on the UI\n}};// Helper function to check if a memory ID is in the savedMemories array\n// Ensures savedMemories is an array before calling .includes()\nconst isMemorySaved=id=>{// console.log(`Checking if ${id} is in`, savedMemories); // Uncomment for verbose check\nreturn Array.isArray(savedMemories)&&savedMemories.includes(id);};return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"h1\",{children:\"Memories\"}),/*#__PURE__*/_jsx(\"ul\",{children:memories.map(memory=>/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"h2\",{children:memory.name}),userID?/*#__PURE__*/_jsx(\"button\",{onClick:()=>saveMemory(memory._id)// Button is disabled if the memory ID is found in the savedMemories state\n,disabled:isMemorySaved(memory._id),children:isMemorySaved(memory._id)?\"Saved\":\"Save\"}):/*#__PURE__*/// Show a message or nothing if the user is not logged in\n_jsx(\"p\",{children:\"Log in to save\"})]}),/*#__PURE__*/_jsx(\"div\",{className:\"descriptions\",children:memory.descriptions&&Array.isArray(memory.descriptions)&&memory.descriptions.map((desc,i)=>/*#__PURE__*/_jsx(\"p\",{children:desc},i))}),/*#__PURE__*/_jsx(\"img\",{src:memory.imageURL,alt:memory.name}),/*#__PURE__*/_jsxs(\"p\",{children:[\"Time Spent: \",memory.timeSpent]})]},memory._id))})]});};","map":{"version":3,"names":["useEffect","useState","axios","useGetUserID","useCookies","jsx","_jsx","jsxs","_jsxs","Home","memories","setMemories","savedMemories","setSavedMemories","cookies","_","userID","fetchMemories","response","get","data","console","log","err","error","fetchSavedMemories","concat","access_token","saveMemory","memoryID","put","headers","authorization","Array","isArray","status","request","message","isMemorySaved","id","includes","children","map","memory","name","onClick","_id","disabled","className","descriptions","desc","i","src","imageURL","alt","timeSpent"],"sources":["D:/Your Memories/client/src/pages/home.js"],"sourcesContent":["import { useEffect, useState } from \"react\";\r\nimport axios from \"axios\";\r\nimport { useGetUserID } from \"../hooks/useGetUserID\";\r\nimport { useCookies } from \"react-cookie\";\r\n\r\nexport const Home = () => {\r\n  const [memories, setMemories] = useState([]);\r\n  // Initialize savedMemories as an empty array\r\n  const [savedMemories, setSavedMemories] = useState([]);\r\n  const [cookies, _] = useCookies([\"access_token\"]);\r\n  const userID = useGetUserID(); // Hook to get the user ID\r\n\r\n  // Effect to fetch initial memories and saved memories\r\n  useEffect(() => {\r\n    // Function to fetch all memories\r\n    const fetchMemories = async () => {\r\n      try {\r\n        const response = await axios.get(\"http://localhost:3001/memories\");\r\n        setMemories(response.data);\r\n        console.log(\"Memories fetched successfully.\");\r\n      } catch (err) {\r\n        console.error(\"Error fetching memories:\", err);\r\n      }\r\n    };\r\n\r\n    // Function to fetch the IDs of memories saved by the current user\r\n    const fetchSavedMemories = async () => {\r\n      if (!userID) {\r\n          console.log(\"userID not available yet, skipping fetchSavedMemories\");\r\n          // Ensure savedMemories is empty if no user is logged in\r\n          setSavedMemories([]);\r\n          return;\r\n      }\r\n      try {\r\n        console.log(\"Attempting to fetch saved memories for userID:\", userID);\r\n        // This GET endpoint should return an object like { savedMemories: [\"id1\", \"id2\"] }\r\n        const response = await axios.get(\r\n          `http://localhost:3001/memories/savedMemories/ids/${userID}`\r\n        );\r\n        console.log(\"Fetched saved memories response:\", response.data);\r\n        // Expecting response.data.savedMemories to be an array. Default to empty array if not.\r\n        // This handles the initial load of saved memory IDs\r\n        setSavedMemories(response.data.savedMemories || []);\r\n        console.log(\"Saved memories state initialized from fetch.\");\r\n      } catch (err) {\r\n        console.error(\"Error fetching saved memories:\", err);\r\n        // In case of error, ensure savedMemories is at least an empty array\r\n        setSavedMemories([]);\r\n      }\r\n    };\r\n\r\n    // Fetch all memories on component mount\r\n    fetchMemories();\r\n\r\n    // Fetch saved memories only if the user is logged in (token and userID available)\r\n    // This will run on mount and whenever the access_token or userID changes\r\n    if (cookies.access_token && userID) {\r\n        fetchSavedMemories();\r\n    } else {\r\n        // If not logged in, ensure savedMemories is an empty array\r\n        setSavedMemories([]);\r\n    }\r\n  }, [cookies.access_token, userID]); // Dependencies: re-run if token or userID changes\r\n\r\n  // Function to handle saving a memory\r\n  const saveMemory = async (memoryID) => {\r\n    console.log(\"Save button clicked for memoryID:\", memoryID);\r\n    console.log(\"Current userID:\", userID);\r\n    console.log(\"Current access_token:\", cookies.access_token);\r\n\r\n    // Prevent saving if user is not logged in or token is missing\r\n    if (!userID || !cookies.access_token) {\r\n        console.log(\"Cannot save: User not logged in or token missing.\");\r\n        // You might want to show a UI message to the user here, e.g., \"Please log in to save memories.\"\r\n        return;\r\n    }\r\n\r\n    try {\r\n      console.log(\"Attempting to send PUT request to save memory...\");\r\n      // This PUT endpoint should expect { memoryID: \"...\", userID: \"...\" }\r\n      // and should *return* the *updated* list of saved memory IDs for the user.\r\n      const response = await axios.put(\r\n        \"http://localhost:3001/memories\", // Make sure this is the correct endpoint for saving\r\n        {\r\n          memoryID,\r\n          userID,\r\n        },\r\n        {\r\n          headers: { authorization: cookies.access_token }, // Sending the auth token\r\n        }\r\n      );\r\n\r\n      console.log(\"Response from PUT /memories:\", response.data);\r\n\r\n      // **IMPORTANT:** We expect response.data to contain the *updated* list of saved memory IDs\r\n      // e.g., { message: \"Saved!\", savedMemories: [\"id1\", \"id2\", \"newlySavedId\"] }\r\n      if (response.data && Array.isArray(response.data.savedMemories)) {\r\n          // Update the savedMemories state with the latest list from the backend\r\n          setSavedMemories(response.data.savedMemories);\r\n          console.log(\"Saved memories state updated successfully from API response.\");\r\n      } else {\r\n          // Log an error if the backend response format is unexpected\r\n          console.error(\"API response did not contain expected 'savedMemories' array:\", response.data);\r\n          // Optionally, re-fetch the saved memories after a short delay\r\n          // setTimeout(fetchSavedMemories, 1000); // Consider adding a delay and error handling\r\n      }\r\n\r\n    } catch (err) {\r\n      console.error(\"Error saving memory:\", err);\r\n      // Log detailed error info if available\r\n      if (err.response) {\r\n          console.error(\"Server responded with error status:\", err.response.status);\r\n          console.error(\"Server error data:\", err.response.data);\r\n      } else if (err.request) {\r\n          console.error(\"No response received from server.\");\r\n      } else {\r\n          console.error(\"Error setting up request:\", err.message);\r\n      }\r\n      // You might want to show an error message to the user on the UI\r\n    }\r\n  };\r\n\r\n  // Helper function to check if a memory ID is in the savedMemories array\r\n  // Ensures savedMemories is an array before calling .includes()\r\n  const isMemorySaved = (id) => {\r\n       // console.log(`Checking if ${id} is in`, savedMemories); // Uncomment for verbose check\r\n       return Array.isArray(savedMemories) && savedMemories.includes(id);\r\n  };\r\n\r\n\r\n  return (\r\n    <div>\r\n      <h1>Memories</h1>\r\n      <ul>\r\n        {/* Map through the list of all memories */}\r\n        {memories.map((memory) => (\r\n          <li key={memory._id}>\r\n            <div>\r\n              <h2>{memory.name}</h2>\r\n              {/* Conditionally render the Save button only if the user is logged in (userID exists) */}\r\n              {userID ? (\r\n                 <button\r\n                   onClick={() => saveMemory(memory._id)}\r\n                   // Button is disabled if the memory ID is found in the savedMemories state\r\n                   disabled={isMemorySaved(memory._id)}\r\n                 >\r\n                   {/* Button text changes based on whether the memory is saved */}\r\n                   {isMemorySaved(memory._id) ? \"Saved\" : \"Save\"}\r\n                 </button>\r\n              ) : (\r\n                  // Show a message or nothing if the user is not logged in\r\n                  <p>Log in to save</p>\r\n              )}\r\n            </div>\r\n            <div className=\"descriptions\">\r\n              {/* Map through descriptions if they exist and are an array */}\r\n              {memory.descriptions && Array.isArray(memory.descriptions) && memory.descriptions.map((desc, i) => (\r\n                <p key={i}>{desc}</p>\r\n              ))}\r\n            </div>\r\n            <img src={memory.imageURL} alt={memory.name} />\r\n            <p>Time Spent: {memory.timeSpent}</p>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n\r\n      {/* Optional: Section to display saved memories - uncomment and adapt as needed */}\r\n       {/* <h2>Saved Memories</h2>\r\n       {Array.isArray(savedMemories) && savedMemories.length > 0 ? (\r\n           <ul>\r\n               {memories\r\n                   // Filter all memories to find saved ones based on the savedMemories IDs\r\n                   .filter(memory => isMemorySaved(memory._id))\r\n                   .map(savedMemory => (\r\n                       <li key={savedMemory._id}>\r\n                           <h3>{savedMemory.name}</h3>\r\n                           {/* Add other details you want to show for saved memories, e.g.: }\r\n                           {/* <p>{savedMemory.timeSpent}</p> }\r\n                           {/* <img src={savedMemory.imageUrl} alt={savedMemory.name} width=\"100\" /> }\r\n                       </li>\r\n                   ))}\r\n           </ul>\r\n       ) : (\r\n           <p>{userID ? \"No memories saved yet.\" : \"Log in to see saved memories.\"}</p>\r\n       )} */}\r\n    </div>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}